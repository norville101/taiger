const path = require('path')
const { MDParams } = require("./mdparams")
const { MDEmbedded } = require('./mdembedded')
const {
  LocalImageFile,
  RemoteImageFile,
} = require('./image')
const {
  Base32,
  EscapeFileName,
  FormatLocalDateTimeANTZ,
  FormatLocalDateTimeISO,
  FormatLocalDateTimeZone,
  GetUrlExtension,
  GetFilenameExtension,
  GetFilenameSuffix,
  TimeCode32,
  TimeCodeHR,
  TrimForTitle,
} = require('./utils')

/* Creation represents a job request that happened at some point in the past, where one or more images
   were generated by some image generation service. It can encapsulate
     * the metadata used to generate the image
     * metadata about the generation itself (when and where the images were generated, etc.)
     * metadta about the generated images themselves
     * (limited) metadata about the source image used for img2img requests (if applicable)
  
   Creations can be constructed from site-specific metadata about a job
     - in which case they can then be used to download the resulting images, name them consistently, and
       embed appropriate metadata into those images for further cataloging with other tools.
   Creations can also be (re)constructed from images downloaded (by this or other methods) in the past,
     - in which case they can be used to normalize file naming and/or embedded metadata.
*/
class Creation {
  constructor () {
    this.id = ''
    this.idShort = ''
    this.orderById = false
    this.fileCreatedAt = null
    this.createdAt = null // new Date()
    this.createdBy = ''
    this.title = ''
    this.metadata = new MDEmbedded()
    this.sourceImageUrl = ''
    this.sourceImageStrength = 0
    this.images = []
    this.compressed = null
    this.upscales = null
  }

  get prefix () {
    if (false) {
      if (this.createdAt) return TimeCode32(this.createdAt)
      if (this.fileCreatedAt) return TimeCode32(this.fileCreatedAt)
    }
    if (this.orderById)
      return this.id
    else
      return this.timePrefix + ' ' + this.id
  }

  get timePrefix () {
    if (false) { // TimeCode32 has subtle issues sorting in unexpected/incorrect order on some of its "extra" vowels!
      if (this.createdAt) return TimeCode32(this.createdAt)
      if (this.fileCreatedAt) return TimeCode32(this.fileCreatedAt)
    }
    // let's settle on a human readable (but unfortunately bulky) format:
    if (this.createdAt) return TimeCodeHR(this.createdAt)
    if (this.fileCreatedAt) return TimeCodeHR(this.fileCreatedAt)
  }

  get fnTitle () {
    if (this.title) return TrimForTitle(this.title)
    if (this.metadata.prompt) return TrimForTitle(this.metadata.prompt)
    return ''
  }

  get prompt () {
    return this.metadata.prompt
  }

  set prompt (value) {
    this.metadata.prompt = value
  }

  get negativePrompt () {
    return this.metadata.negativePrompt
  }

  set negativePrompt (value) {
    this.metadata.negativePrompt = value
  }

  getFileName (img, useAlt = false) {
    if (this.images.length === 0) throw new Error('there are no images')
    let numSuffix = (typeof img.fnImageNum === 'string' && img.fnImageNum !== '') ? '-' + img.fnImageNum : ''
    if (img.fnScale) numSuffix += ` x${img.fnScale}`
    const prefix = this.prefix + numSuffix
    let title
    if (this.orderById) { // ID is suitable for ordering by creation date, leaves room for title
      title = this.fnTitle.substring(0, 80).trim()
    } // else time prefix + potentially long ID -> not much room for meaningful title
    return prefix + (title ? ' ' + title : '') + (useAlt ? img.extAlt : img.ext)
  }

  getParam (name) {
    return this.metadata.getParam(name)
  }

  setParam (name, value) {
    this.metadata.setParam(name, value)
  }

  get hasDate () {
    return Boolean(this.createdAt || this.publishedAt)
  }

  getLocalDateANTZ (dateOverride) {
    if (dateOverride) {
      return FormatLocalDateTimeANTZ(dateOverride)
    }
    if (this.createdAt) {
      return FormatLocalDateTimeANTZ(this.createdAt)
    }
    if (this.publishedAt) {
      return FormatLocalDateTimeANTZ(this.publishedAt)
    }
    if (this.fileCreatedAt) {
      return FormatLocalDateTimeANTZ(this.fileCreatedAt)
    }
    return null
  }

  getLocalTimeZone (dateOverride) {
    if (dateOverride) {
      return FormatLocalDateTimeZone(dateOverride)
    }
    if (this.createdAt) {
      return FormatLocalDateTimeZone(this.createdAt)
    }
    if (this.publishedAt) {
      return FormatLocalDateTimeZone(this.publishedAt)
    }
    if (this.fileCreatedAt) {
      return FormatLocalDateTimeZone(this.fileCreatedAt)
    }
    return null
  }

  getLocalDateISO (dateOverride) {
    if (dateOverride) {
      return FormatLocalDateTimeISO(dateOverride)
    }
    if (this.createdAt) {
      return FormatLocalDateTimeISO(this.createdAt)
    }
    if (this.publishedAt) {
      return FormatLocalDateTimeISO(this.publishedAt)
    }
    if (this.fileCreatedAt) {
      return FormatLocalDateTimeISO(this.fileCreatedAt)
    }
    return null
  }

  getUTCDateISO (dateOverride) {
    if (dateOverride) {
      return dateOverride.toISOString()
    }
    if (this.createdAt) {
      return this.createdAt.toISOString()
    }
    if (this.publishedAt) {
      return this.publishedAt.toISOString()
    }
    if (this.fileCreatedAt) {
      return this.fileCreatedAt.toISOString()
    }
    return null
  }

  toMDString (seedOverride) {
    return this.metadata.toString(seedOverride)
  }

  getTagsToEmbed (img, toEmbed = {}) {
    let UserComment
    if (this.metadata.hasData) {
      UserComment = this.metadata.toString(img.seedOverride)
    }
    if (UserComment) {
      toEmbed['UserComment'] = UserComment
    }
    if (img.ext === '.png') {
      if (UserComment) {
        toEmbed['PNG:parameters'] = UserComment
      }
      if (this.url) {
        toEmbed['PNG:URL'] = this.url
      }
      if (this.hasDate) {
        toEmbed['PNG:CreationTime'] = this.getLocalDateISO() // Windows Explorer "Date Taken" for PNGs
      }
    }
    if (this.hasDate) {
      // set date/time when original image was "taken" (for non-PNGs)
      toEmbed['EXIF:DateTimeOriginal'] = this.getLocalDateANTZ()
      toEmbed['EXIF:OffsetTimeOriginal'] = this.getLocalTimeZone()
      // set date/time image was "digitized"
      toEmbed['EXIF:CreateDate'] = this.getLocalDateANTZ()
      toEmbed['EXIF:OffsetTimeDigitized'] = this.getLocalTimeZone()
    }
    if (this.createdBy) {
      toEmbed['EXIF:Software'] = this.createdBy
    }
    if (this.id) {
      toEmbed['EXIF:ReelName'] = this.id
    }
    if (typeof img.imageNumber === 'number') {
      toEmbed['EXIF:ImageNumber'] = img.imageNumber
    } else if (typeof img.fnImageNum === 'string' && img.fnImageNum !== '') {
      toEmbed['EXIF:ImageNumber'] = Number.parseInt(img.fnImageNum)
    }
    // store image's unique ID
    if (img.uniqueId) {
      toEmbed['EXIF:ImageUniqueID'] = String(img.uniqueId).replace(/\-/g, '')
    }
    return toEmbed
  }

  static async ExtractMetadataFromImage (filepath, exiftool) {
    throw new Error('Obsolete code called')
    const result = {}
    result.file = filepath
    // get creation time of the file
    const stats = await fsp.stat(filepath)
    const modified = stats.mtime // last file modification
    const created = stats.birthtime // file creation
    result.fileCreatedAt = (modified < created) ? modified : created
    // see what we can get out of filename (helpful if little or no other metadata exists)
    const filename = path.basename(filepath)
    result.name = filename
    const match = Creation.filenameRE.exec(filename)
    if (match) {
      result.fnprefix = match.groups['prefix']
      result.fnImageNum = match.groups['num']
      result.fnlabel = match.groups['label']
      result.ext = match.groups['ext']
    } else {
      result.ext = GetFilenameExtension(filename)
    }
    if (result.ext && ['.png', '.jpg', '.jpeg', '.webp'].includes(result.ext.toLowerCase())) {
      // extract additional metadata FROM image...
      const embedded = await exiftool.read(filepath, ['-G'])
      if (embedded['PNG:CreationTime']) {
        result.createdAt = embedded['PNG:CreationTime']
      } else if (embedded['EXIF:DateTimeOriginal']) {
        result.createdAt = embedded['EXIF:DateTimeOriginal']
        // if (embedded['EXIF:OffsetTimeOriginal']) { // already handled in exiftool.read()?
        //   result.createdAt += embedded['EXIF:OffsetTimeOriginal']
        // }
      } else if (embedded['EXIF:CreateDate']) {
        result.createdAt = embedded['EXIF:CreateDate']
        // if (embedded['EXIF:OffsetTimeDigitized']) { // already handled in exiftool.read()?
        //   result.createdAt += embedded['EXIF:OffsetTimeDigitized']
        // }
      }
      if (result.createdAt && result.createdAt.toDate) {
        result.createdAt = result.createdAt.toDate() // we want a plain old JS date, not a fancy ExifDateTime object
      }
      if (embedded['EXIF:UserComment']) {
        result.UserComment = embedded['EXIF:UserComment']
      }
      if (embedded['EXIF:Software']) {
        result.software = embedded['EXIF:Software']
      }
      if (embedded['EXIF:ReelName']) {
        result.reelName = embedded['EXIF:ReelName']
      }
      if (embedded['EXIF:ImageNumber']) {
        result.imageNumber = embedded['EXIF:ImageNumber']
      }
      if (embedded['EXIF:ImageUniqueID']) {
        result.uniqueId = embedded['EXIF:ImageUniqueID']
      }
      if (embedded['PNG:parameters']) {
        result['PNG:parameters'] = embedded['PNG:parameters']
      }
      if (embedded['PNG:URL']) {
        result.URL = embedded['PNG:URL']
      }
      if (embedded['EXIF:ImageHistory']) {
        result.ImageHistory = embedded['EXIF:ImageHistory']
      }
      if (embedded['PNG:GenInfo']) {
        const genInfo = JSON.parse(embedded['PNG:GenInfo'])
        result['dezgo-GenInfo'] = genInfo
      }
      if (embedded['PNG:GenCode']) {
        result['dezgo-GenCode'] = embedded['PNG:GenCode']
      }
    }
    return result
  }

  static fromExtractedMetadata (metadata) {
    if (Array.isArray(metadata)) {
      let creation
      for (const md of metadata) {
        if (!creation) { // first one
          creation = Creation.fromExtractedMetadata(md)
        } else {
          creation.addFileFromExtractedMetadata(md)
        }
      }
      return creation
    }
    const creation = new Creation()
    // stuff potentially gleaned from filename:
    if (metadata.fnprefix) creation.id = metadata.fnprefix
    if (metadata.fnlabel) creation.title = metadata.fnlabel
    // stuff potentially gleaned from file date
    if (metadata.fileCreatedAt) creation.fileCreatedAt = metadata.fileCreatedAt
    // stuff potentially extracted from embedded EXIF and/or PNG metadata:
    if (metadata.createdAt) creation.createdAt = metadata.createdAt
    if (metadata.UserComment) {
      creation.metadata = new MDEmbedded(metadata.UserComment)
      if (creation.metadata.prompt) creation.title = TrimForTitle(creation.metadata.prompt)
    }
    if (metadata['PNG:parameters']) {
      creation.pngParams = metadata['PNG:parameters']
    }
    if (metadata['PNG:URL']) {
      creation.pageUrl = metadata['PNG:URL']
    }
    if (metadata.software) creation.createdBy = metadata.software
    else if (('dezgo-GenInfo' in metadata) || ('dezgo-GenCode' in metadata)) creation.createdBy = 'Dezgo'
    else if (creation.metadata.getParam('Civitai resources')) creation.createdBy = 'Civitai'
    if (metadata.reelName) {
      creation.id = metadata.reelName
      if (metadata.fnprefix) creation.idShort = metadata.fnprefix
    }
    creation.addFileFromExtractedMetadata(metadata)
    return creation
  }

  addFileFromExtractedMetadata (metadata) {
    const imgCount = this.images.length
    const imgObj = {
      file: metadata.file,
      name: metadata.name,
      createdAt: metadata.fileCreatedAt,
      ext: metadata.ext,
    }
    if (metadata.uniqueId) imgObj.id = metadata.uniqueId
    if (metadata.fnlabel) imgObj.title = metadata.fnlabel
    let thisNum = metadata.imageNumber
    if (typeof thisNum === 'string' || typeof thisNum === 'number')
      imgObj.num = String(thisNum)
    else {
      thisNum = metadata.fnImageNum
      if (typeof thisNum === 'string' || typeof thisNum === 'number')
        imgObj.num = String(thisNum)
    }
    if (typeof imgObj.num === 'string') {
      let insPos = 0
      while (insPos < imgCount && imgObj.num > this.images[insPos].num) {
        insPos++
      }
      this.images.splice(insPos, 0, imgObj)
    } else {
      if (imgCount > 0) {
        imgObj.num = String(imgCount)
        if (imgCount == 1 && !this.images[0].num) {
          this.images[0].num = '0'
        }
      }
      this.images.push(imgObj)
    }
  }
}
exports.Creation = Creation

Creation.filenameRE = /^(?<prefix>[A-Fa-f0-9]{6,64})?(?:-?(?<num>\d{1,2})\s*-?\s*)?(?<label>.*)?(?<ext>\.[A-Za-z]{3,4})$/
